<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>WebRTC Call</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 0;
      padding: 20px;
      transition: background 0.3s, color 0.3s;
    }
    video {
      width: 45%;
      border: 2px solid currentColor;
      border-radius: 8px;
      margin: 5px;
    }
    button, select {
      margin: 6px;
      padding: 8px 14px;
      font-size: 14px;
      cursor: pointer;
    }
    #inviteBox {
      margin: 15px auto;
      padding: 12px;
      border: 1px solid currentColor;
      background: inherit;
      max-width: 700px;
      text-align: left;
      border-radius: 8px;
    }
    .invite-row {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 8px;
    }
    .invite-row input {
      flex: 1;
      padding: 6px;
      font-size: 13px;
      border: 1px solid currentColor;
      background: inherit;
      color: inherit;
    }
    .muted {
      opacity: 0.8;
      font-size: 13px;
    }
    #qrcode {
      margin-top: 10px;
      text-align: center;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
</head>
<body>
  <h2>WebRTC –í–∏–¥–µ–æ–∑–≤–æ–Ω–æ–∫</h2>

  <div>
    <label for="theme">üé® –¢–µ–º–∞: </label>
    <select id="theme" onchange="setTheme(this.value)">
      <option value="white">–ë–µ–ª–∞—è</option>
      <option value="darkgray">–¢—ë–º–Ω–æ-—Å–µ—Ä–∞—è</option>
      <option value="black">–ß—ë—Ä–Ω–∞—è</option>
    </select>
  </div>

  <div id="inviteBox">
    <p class="muted">–û—Ç–ø—Ä–∞–≤—å —ç—Ç—É —Å—Å—ã–ª–∫—É –¥—Ä—É–≥—É –∏–ª–∏ –ø–æ–∫–∞–∂–∏ QR-–∫–æ–¥. –î—Ä—É–≥ –æ—Ç–∫—Ä–æ–µ—Ç –µ—ë –∏ –±—É–¥–µ—Ç –∂–¥–∞—Ç—å –∑–≤–æ–Ω–∫–∞.</p>

    <div class="invite-row">
      <label style="min-width:140px;">–°—Å—ã–ª–∫–∞ –¥–ª—è —É—á–∞—Å—Ç–Ω–∏–∫–∞:</label>
      <input id="inviteLink" type="text" readonly>
      <button onclick="copyInvite()">üìã –°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
    </div>

    <div id="qrcode"></div>
  </div>

  <div>
    <video id="localVideo" autoplay muted></video>
    <video id="remoteVideo" autoplay></video>
  </div>

  <div>
    <button onclick="createOffer()">üìû –ü–æ–∑–≤–æ–Ω–∏—Ç—å</button>
    <button onclick="endCall()">‚ùå –ó–∞–≤–µ—Ä—à–∏—Ç—å –∑–≤–æ–Ω–æ–∫</button>
  </div>

  <script>
    // --- Room/URL ---
    const urlParams = new URLSearchParams(window.location.search);
    let ROOM = urlParams.get('room');
    let isCaller = urlParams.has('call');

    if (!ROOM) {
      ROOM = Math.random().toString(36).slice(2, 8);
      const callerUrl = `${window.location.origin}${window.location.pathname}?room=${ROOM}&call`;
      window.history.replaceState({}, "", callerUrl);
      isCaller = true;
    }

    const baseRoomUrl = `${window.location.origin}${window.location.pathname}?room=${encodeURIComponent(ROOM)}`;
    const callerUrl = `${baseRoomUrl}&call`;

    document.getElementById('inviteLink').value = baseRoomUrl;

    let qr;
    function renderQR(fg = "#000", bg = "#fff") {
      const qrBox = document.getElementById("qrcode");
      qrBox.innerHTML = "";
      qr = new QRCode(qrBox, {
        text: baseRoomUrl,
        width: 180,
        height: 180,
        colorDark: fg,
        colorLight: bg
      });
    }

    // --- Theme handling ---
    function setTheme(theme) {
      if (theme === "white") {
        document.body.style.background = "#ffffff";
        document.body.style.color = "#000000";
        renderQR("#000000", "#ffffff");
      } else if (theme === "darkgray") {
        document.body.style.background = "#2b2b2b";
        document.body.style.color = "#ffffff";
        renderQR("#ffffff", "#2b2b2b");
      } else if (theme === "black") {
        document.body.style.background = "#000000";
        document.body.style.color = "#ffffff";
        renderQR("#ffffff", "#000000");
      }
    }

    // –£—Å—Ç–∞–Ω–æ–≤–∏–º –±–µ–ª—É—é —Ç–µ–º—É –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    setTheme("darkgray");

    // --- Copy link ---
    function copyInvite() {
      const txt = document.getElementById('inviteLink').value;
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(txt)
          .then(() => { alert('–°—Å—ã–ª–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞ –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞'); })
          .catch(() => { fallbackCopy(txt); });
      } else {
        fallbackCopy(txt);
      }
    }
    function fallbackCopy(text) {
      const ta = document.createElement('textarea');
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      try {
        document.execCommand('copy');
        alert('–°—Å—ã–ª–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞ –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞');
      } catch (e) {
        alert('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å. –°–∫–æ–ø–∏—Ä—É–π –≤—Ä—É—á–Ω—É—é:\n' + text);
      }
      document.body.removeChild(ta);
    }

    // --- WebRTC ---
    const SIGNAL_URL = 'https://webrtc-signal-78yj.onrender.com';
    const CLIENT_ID = Math.random().toString(36).slice(2);

    const config = {
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        {
          urls: "turn:openrelay.metered.ca:80",
          username: "openrelayproject",
          credential: "openrelayproject"
        }
      ]
    };

    const pc = new RTCPeerConnection(config);
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    let iceCandidateBuffer = [];
    let hasRemoteDescription = false;
    let isCallActive = false;

    navigator.mediaDevices.getUserMedia({ video: true, audio: true })
      .then(stream => {
        localVideo.srcObject = stream;
        stream.getTracks().forEach(track => pc.addTrack(track, stream));
      })
      .catch(err => alert("–û—à–∏–±–∫–∞ –∫–∞–º–µ—Ä—ã: " + err));

    pc.ontrack = e => remoteVideo.srcObject = e.streams[0];

    async function sendSignalPayload(payload) {
      const msg = Object.assign({}, payload, { room: ROOM, from: CLIENT_ID });
      try {
        await fetch(SIGNAL_URL + '/send', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(msg)
        });
      } catch (e) {
        console.error('Send failed', e);
      }
    }

    function flushIceCandidates() {
      iceCandidateBuffer.forEach(async candidate => {
        try { await pc.addIceCandidate(candidate); } 
        catch (e) { console.error("ICE candidate error:", e); }
      });
      iceCandidateBuffer = [];
    }

    async function receiveLoop() {
      while (true) {
        try {
          const res = await fetch(`${SIGNAL_URL}/receive?room=${encodeURIComponent(ROOM)}&clientId=${encodeURIComponent(CLIENT_ID)}`);
          if (res.status === 200) {
            const msg = await res.json();

            if (msg.type === 'offer') {
              if (isCallActive) continue;
              isCallActive = true;
              await pc.setRemoteDescription({ type: msg.type, sdp: msg.sdp });
              hasRemoteDescription = true;
              const answer = await pc.createAnswer();
              await pc.setLocalDescription(answer);
              await sendSignalPayload({ type: answer.type, sdp: answer.sdp });
              flushIceCandidates();
            } else if (msg.type === 'answer') {
              if (isCallActive) continue;
              isCallActive = true;
              await pc.setRemoteDescription({ type: msg.type, sdp: msg.sdp });
              hasRemoteDescription = true;
              flushIceCandidates();
            } else if (msg.type === 'candidate') {
              if (hasRemoteDescription) {
                await pc.addIceCandidate(msg.candidate);
              } else {
                iceCandidateBuffer.push(msg.candidate);
              }
            } else {
              console.log('Unknown message:', msg);
            }
          } else if (res.status === 204) {
            // long polling timeout
          } else {
            console.warn('Receive unexpected status', res.status);
          }
        } catch (e) {
          console.error("Receive error:", e);
          await new Promise(r => setTimeout(r, 1500));
        }
      }
    }

    pc.onicecandidate = e => {
      if (e.candidate) {
        sendSignalPayload({ type: 'candidate', candidate: e.candidate });
      }
    };

    receiveLoop();

    window.createOffer = async () => {
      if (!isCaller) {
        alert("–¢—ã –Ω–µ –º–æ–∂–µ—à—å –∑–≤–æ–Ω–∏—Ç—å. –û—Ç–∫—Ä–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—É –∑–≤–æ–Ω—è—â–µ–≥–æ:\n" + callerUrl);
        return;
      }

      try {
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        await sendSignalPayload({ type: offer.type, sdp: offer.sdp });
        console.log("‚úÖ Offer sent");
      } catch (e) {
        console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –≤—ã–∑–æ–≤–∞:", e);
        alert("–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞—á–∞—Ç—å –≤—ã–∑–æ–≤: " + e.message);
      }
    };

    window.endCall = () => {
      if (localVideo.srcObject) {
        localVideo.srcObject.getTracks().forEach(track => track.stop());
        localVideo.srcObject = null;
      }
      remoteVideo.srcObject = null;
      try { pc.close(); } catch (e) {}
      isCallActive = false;
      console.log("üìû Call ended");
      alert("–ó–≤–æ–Ω–æ–∫ –∑–∞–≤–µ—Ä—à—ë–Ω");
    };
  </script>
</body>
</html>
